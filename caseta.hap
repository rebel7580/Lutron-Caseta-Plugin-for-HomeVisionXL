# Caseta Client plugin for HomeVision - Ron Boston
# Version 2.0
# $Revision: 1.32 $
# $Date: 2021/03/14 22:02:58 $
# $Requires: HomeVisionXL 2.3 $

# This plugin uses features introduced in version 2.3
if {[hvVersion] < 2.0 || ![package vsatisfies [hvVersion] 2.3-]} {
    error "Need HomeVisionXL version 2.3 or higher"
}

set version {$Id: caseta.hap,v 1.32 2021/03/14 22:02:58 ron Exp $}

hvImport debug
hvImport action
hvImport mqttComm

#! Plugin directory location
set script [file normalize [file join [pwd] [info script]]]
set dir [file dirname $script]
set cfgfileroot [file tail [file rootname [info script]]]
lappend auto_path $dir
tcl::tm::path add $dir

set connected 0
set loginStatus 1
set currentItem ""
set logsuspend 0

array set cfg {
    serPre      "caseta:"
    serPost     ";"
    netioType   "caseta"
    geometry    ""
    HubIP       ""
    HubPort     23
    username    "lutron"
    password    "integration"
    listWidths  {0 0 0}
    logging     0
    logpath     ""
    attempts    5
    mqttEnable  0
}
set cfg(txtext) [expr {$tcl_platform(platform) eq "windows" ? ".txt" : ""}]
set cfg(CasetaConfigFile) [file join $dir CasetaConfig.json]

set casetatypes {
    none          ""
    light         "Light"
    switch        "Switch"
    binary_sensor "Sensor"
    cover         "Curtain"
    fan           "Fan"
    scene         "Scene"
}

# Start Client Section

# Start the client
proc startClient {attempts} {
    global cfg sockChan loginStatus

    set loginStatus 0
    catch {close $sockChan}
    if {$cfg(username) eq "" || $cfg(password) eq ""} {
        casetaLog "No username/password" red
        return
    }
    casetaLog "(Re)starting Client" blue
    if {[catch {socket $cfg(HubIP) $cfg(HubPort)} sockChan]} {
        casetaLog "*** Client FAILED ***: $sockChan" red
        if {$attempts > 0} {
            casetaLog "Retrying..." red
            after 2000 [list startClient [incr attempts -1]]
        } else {
            casetaLog "No more attempts" red
        }
        return
    }
    chan configure $sockChan -blocking false
    casetaLog "Client Started: $sockChan, [chan configure $sockChan -sockname]" darkslategray
    # set up to read data from socket
    chan event $sockChan readable [list readData $sockChan]
}

# procedure to read data from socket
proc readData {f} {
    global cfg

    debug "readData!" red
    set line ""
    if {[catch {chan read $f} line]} {
        debug "error: $line" blue
        return
    }
    if {[chan eof $f]} {
        debug "no input" blue
        catch {chan close $f}
        after 2000 [list startClient $cfg(attempts)]
        return
    }
    debug $line green
    if {$line != -1} {
        foreach l [split $line \n] {
            parseLine $f $l
        }
    }
}

proc parseLine {s line} {
    global cfg statusIndex

    switch -regexp -matchvar result -- $line {
        "ogin:" {
            sendData $cfg(username)
        }
        "assword" {
            sendData $cfg(password)
            set statusIndex 0
            casetaLog "logged in"
        }
        "~OUTPUT" {
            processOutput $line
        }
        "~DEVICE" {
            processDevice $line
        }
        "~ERROR" {
            regsub -all {GNET>} $line "" line
            set line [string map {> "" " " "" \n ""} $line]
            casetaLog $line
        }
        ">" {
            debug "prompt" blue
            if {$statusIndex == 0} {
                doOneStatus
            }
        }
        default {
            debug "$line" green
        }
    }
}

proc doOneStatus {} {
    if {[getStatus]} {
        after idle [list after 0 doOneStatus]
    }
}

proc getStatus {} {
    global CasetaConfig statusIndex

    if {![info exists CasetaConfig] || ![dict exists $CasetaConfig Zones ID]} {return 0}
    set ids [dict get $CasetaConfig Zones ID]
    set size [expr {[llength $ids] / 2}]
    set id [lindex $ids [expr { $statusIndex*2}]]
    set resp [join [list "?OUTPUT" $id 1] ","]
    incr statusIndex
    sendData $resp
    if {$statusIndex < $size} {
        return 1
    } else {
        return 0
    }
}

proc processOutput {line} {
    global cfg deviceState CasetaConfig

    regsub -all {GNET>} $line "" line
    set line [string map {> "" " " "" \n ""} $line]
    debug "received OUTPUT:$line" darkgreen
    lassign [split $line ","] type id action level ramp
    if {(![string is integer -strict $level]  \
         && ![string is double  -strict $level])} {
        casetaLog "Invalid level:$level;line:$line;" red
        return
    }
    if {![string is integer -strict $id]} {
        casetaLog "Invalid id:$id;line:$line;" red
        return
    }
    set found 0
    foreach {i j} [dict get $CasetaConfig Zones ID] {
        if {$i == $id} {
            set found 1
            break
        }
    }
    if {$found == 0} {
        casetaLog "Id not found:$id;line:$line;" red
        return
    }

    dict set deviceState id $id level $level
#    debug "[dict get $deviceState]" blue

    set row [mk::select cfg.devices id $id]
    if {$row ne ""} {
        lassign [mk::get cfg.devices!$row flag macro_on macro_off loglevel varflag model] flag macro_on macro_off loglevel varflag model
        if {$level == 0} {
            if {$flag ne "" && $flag < 512} {
                if {$flag < 256} {
                    myaction flag clear $flag
                } else {
                    set flag [expr {$flag - 256}]
                    myaction var set $flag 0
                    myaction var update
                }
            }
            if {$macro_off ne "" && $macro_off < 256} {
                myaction macro run $macro_off
            }
            set payload "OFF"
        } else {
            if {$flag ne "" && $flag < 512} {
                if {$flag < 256} {
                    myaction flag set $flag
                } else {
                    if {$varflag & 0x01} {
                        set level 1
                    }
                    set flag [expr {$flag - 256}]
                    myaction var set $flag [expr {int($level)}]
                    myaction var update
                }
            }
            if {$macro_on ne "" && $macro_on < 256} {
                myaction macro run $macro_on
            }
            if {$model eq "light" || $model eq ""} {
                set payload "ON [expr {int($level)}]"
            } else {
                set payload "ON"
            }
        }

        if {![info exists CasetaConfig] || ![dict exists $CasetaConfig Zones ID]} {
            if {$loglevel & 0x01} {
                casetaLog "Unknown: $line" darkgreen
            }
        } else {
            if {$cfg(mqttEnable)} {
                if {$model eq "light" || $model eq ""} {
                    mqttComm stat <[dict get $CasetaConfig Zones ID $id]> $payload
                } else {
                    mqttComm -nodim stat <[dict get $CasetaConfig Zones ID $id]> $payload
                }
            }
            if {$loglevel & 0x01} {
                casetaLog "[dict get $CasetaConfig Zones ID $id]: $line" darkgreen
            }
        }
        createDevList
    }
}

 proc processDevice {line} {
    global cfg CasetaConfig

    regsub -all {GNET>} $line "" line
    set line [string map {> "" " " "" \n ""} $line]
    debug "received DEVICE:$line" darkgreen
    lassign [split $line ","] type id button action
    if {![string is integer -strict $id]} {
        casetaLog "Invalid id:$id;line:$line;" red
        return
    }
    if {![string is integer -strict $button]} {
        casetaLog "Invalid button:$id,$button;line:$line;" red
        return
    }
    if {![string is integer -strict $action]} {
        casetaLog "Invalid button:$id,$button;line:$line;" red
        return
    }
    if {$action != 3} {
        # ignore if not a "press" action
        return
    }
    set found 0
    foreach {i j} [dict get $CasetaConfig Devices Buttons $id] {
        if {$j == $button} {
            set found 1
            break
        }
    }
    if {$found == 0} {
        casetaLog "Id/button not found:$id,$button;line:$line;" red
        return
    }
    set row [mk::select cfg.devices id $id:$button]
    if {$row ne ""} {
        lassign [mk::get cfg.devices!$row loglevel macro_on name] loglevel macro_on name
        if {$macro_on ne "" && $macro_on < 256} {
            myaction macro run $macro_on
        }
        if {$cfg(mqttEnable)} {
            mqttComm -nodim stat <$name> On
        }
        if {$loglevel & 0x01} {
            casetaLog "$name: $line" darkgreen
        }
        createDevList
    }
}

proc sendData {resp} {
    global sockChan

    if {[catch {chan puts $sockChan $resp} rc]} {
        debug "$sockChan: Send of $resp failed: $rc" red
        discinit
    } else {
        debug "$sockChan: Sent $resp;"
    }
    if {[catch {chan flush $sockChan} rc]} {
        debug "$sockChan: Flush of $resp failed: $rc" red
    }
}

# sendCmd
#
# if called with name, state:
#    name must be a device name
#    state must be 0-100
# if called by name only, name must be in one of the following forms:
#    device name on         - on 100%
#    device name on 0-100   - on 0-100%
#    device name 0-100      - on 0-100%
#    device name off        - off
proc sendCmd {name {state ""}} {
    global CasetaConfig

    debug "sendCmd:$name,$state;" blue

    if {$state eq ""} {
        set state [lindex $name end]
        set name [lrange $name 0 end-1]
        if {[string equal -nocase $state "on"]} {
            set st 100
        } elseif {[string equal -nocase $state "off"]} {
            set st 0
        } else {
                if {![string is integer -strict $state] || \
                    $state < 0 || $state > 100} {
                    return
                }
                scan $state %d st
            if {[lindex $name end] eq "on"} {
                set name [lrange $name 0 end-1]
            }
        }
    } else {
        set st $state
    }
#    debug "5:name:$name,state:$state;st:$st;" red

    set name [join $name]
    if {![info exists CasetaConfig] || ![dict exists $CasetaConfig Zones Name $name]} {return}
    set id [dict get $CasetaConfig Zones Name $name]
    set resp [join [list "#OUTPUT" $id 1 $st] ","]

    set row [mk::select cfg.devices id $id]
    if {$row ne ""} {
        if {[mk::get cfg.devices!$row loglevel] & 0x02} {
            casetaLog $resp blue
        }
    }
    sendData $resp
}

#! Write status information to log file
proc casetaLog {str {color red}} {
    global loghandle casetaLogdate cfg logsuspend dir

    debug $str $color
    if {!$cfg(logging) || $logsuspend == 2} return
    set time [clock seconds]
    set date [clock format $time -format %y%m%d]
    if {![info exists loghandle] || $date ne $casetaLogdate} {
        if {[info exists loghandle]} {
            catch {close $loghandle}
        }
        set t 0
        foreach logpath [list $cfg(logpath) [file join $dir log]] {
            if {[catch {file mkdir $logpath}]} {
                debug "Failed to access Caseta log directory,$logpath" red
                incr t
                continue
            }
            set file [file join $logpath CasetaLog$date$cfg(txtext)]
            if {[catch {open $file a} loghandle]} {
                unset loghandle
                debug "Failed to open Caseta log file,$file" red
                incr t
                continue
            }
            set casetaLogdate $date
            break
        }
        set logsuspend $t
        if {$t >= 2} {
            debug "Suspend logging for 5 mins" red
            after 300000 restorelogging
            return 0
        }
    } elseif {[info exists loghandle] && $logsuspend == 1} {
        #retry orig logpath
        set logpath $cfg(logpath)
        if {[catch {file mkdir $logpath}]} {
            # Failed orig logpath, keep alternate
        } else {
            # Found orig, try a file
            set file [file join $logpath CasetaLog$date$cfg(txtext)]
            if {[catch {open $file a} lh]} {
                # Failed orig log file, keep alternate
                unset lh
                debug "Failed to open Caseta log file,$file" red
            } else {
                debug "Reopened original log file,$file" blue
                if {[info exists loghandle]} {
                    catch {close $loghandle}
                }
                set loghandle $lh
                set logsuspend 0
                set casetaLogdate $date
            }
        }
    }
    catch {puts -nonewline $loghandle "[clock format $time -format "%d.%m.%Y %H.%M.%S"]\t$str\n"}
    catch {flush $loghandle}
    return 1
}

proc restorelogging {} {
    global logsuspend

    #after timeout, try again to log next time.
    set logsuspend 0
}

# Subscribe Zone entries to MQTT, if enabled
proc subscribe {{type sub} {attempts 5}} {
    global cfg CasetaConfig CasetaMqttSub

    debug "subscribe:$type" blue
    if {![info exists CasetaConfig] || ![dict exists $CasetaConfig Zones Name]} {return}
    if {$cfg(mqttEnable) && $type eq "sub"} {
        foreach {name id} [dict get $CasetaConfig Zones Name] {
#            debug "$type name:$name" red
            dict set CasetaMqttSub $name $type
            set r [mqttComm $type <$name> casetaStatus]
        }
        if {$type eq "sub" && [lindex $r 0] eq "" && $attempts > 0} {
            debug "retry" red
            after 5000 [list subscribe sub [incr attempts -1]]
        }
    } else {
        foreach {name id} [dict get $CasetaConfig Zones Name] {
#            debug "unsub name:$name" red
            if {[info exists CasetaMqttSub] && [dict exists $CasetaMqttSub $name]} {
                if {[dict get $CasetaMqttSub $name] eq "sub"} {
                    dict unset CasetaMqttSub $name
                    mqttComm "unsub" <$name>
                }
            }
        }
    }
}

# Call back for Caseta devices
hvImport topicTemplate
hvPublic casetaStatus
proc casetaStatus {topic payload {retain 0}} {
    global cfg deviceState CasetaConfig

    debug "CasetaStatus:$topic,$payload,$retain;" red

    set tmpl {*}[topicTemplate $topic]
    set name [dict get $tmpl topic name]
    debug "name:$name;" red
    if {![info exists CasetaConfig] || ![dict exists $CasetaConfig Zones Name $name]} {return}
    set id [dict get $CasetaConfig Zones Name $name]
    if {[info exist deviceState] && [dict exists $deviceState id $id]} {
        set level [expr {int([dict get $deviceState id $id level])}]
    } else {
        set level "Unknown"
    }
    if {$payload eq {} || $payload eq "?"} {
        if {$level eq "Unknown"} {
            set rc $level
        } elseif {$level == 0} {
            set rc "OFF"
        } else {
            set rc "ON $level"
        }
        debug "rc:$rc;" red
        set row [mk::select cfg.devices id $id]
        if {$row ne ""} {
            lassign [mk::get cfg.devices!$row model] model
            if {$model eq "light"} {
                mqttComm stat <[dict get $CasetaConfig Zones ID $id]> $rc
            } else {
                mqttComm -nodim stat <[dict get $CasetaConfig Zones ID $id]> $rc
            }
        } else {
            mqttComm -nodim stat <[dict get $CasetaConfig Zones ID $id]> $rc
        }
    } else {
        if {[string tolower $payload] eq "toggle"} {
            if {$level eq "Unknown"} {
                return
            } elseif {$level == 0} {
                set rc "ON"
            } else {
                set rc "OFF"
            }
        } else {
            set rc $payload
        }
        netioaction caseta caseta $name $rc
    }
}

hvImport sendDiscovery
hvPublic haObjectDiscovery
proc haObjectDiscovery {args} {
    global cfg objtypes

    debug "HA Discovery"

    set noid 0
    set nous 0
    set retain 0
    while 1 {
        if {[lindex $args 0] eq "-noid"} {
            set noid 1
            set args [lrange $args 1 end]
            continue
        }
        if {[lindex $args 0] eq "-nous"} {
            set nous 1
            set args [lrange $args 1 end]
            continue
        }
        if {[lindex $args 0] eq "-retain"} {
            set retain 1
            set args [lrange $args 1 end]
            continue
        }
        break
    }
    set args [lassign $args add]    
    set ids [lassign $args otype]

    if {$otype ne "" && [string tolower $otype] ni {caseta}} {
        return
    }
    mk::loop row cfg.devices {
        lassign [mk::get $row id name model] id name model
        if {[string match {*:*} $id]} {
            continue
        }
        if {$ids eq "" || $id in $ids} {
            sendDiscovery $noid $nous $retain $add $id $name $name caseta $model Caseta Lutron
        }
    }
}


proc myaction {args} {
    global connected

    if {$connected} {
        action {*}$args
    }
}

# End Client Section

# Start Config Section

proc loadConfig {} {
    global cfgfile cfgfileroot cfg CasetaConfig

    package require Mk4tcl

    set suffix [hvVariable ApplicationSuffix]
    if {$suffix eq ""} {
        set cfgfile $cfgfileroot.cfg
    } else {
        set cfgfile $cfgfileroot-$suffix.cfg
    }

    mk::file open cfg
    if {![catch {hvConfigFile open $cfgfile} f]} {
        mk::file load cfg $f
        close $f
    }
    # General settings
    mk::view layout cfg.main {
        name value
    }
    # Devices
    mk::view layout cfg.devices {
        name id state flag macro_on macro_off varflag loglevel model
    }

    if {[catch {hvConfig Geometry} geometry]} {
        set geometry ""
    }

    set cfg(version) 1
    # update config
    mk::loop row cfg.main {
        array set cfg [mk::get $row name value]
    }

    set saveflag 0
    getCasetaConfig
    foreach {name id} [dict get $CasetaConfig Zones Name] {
        set idx [mk::select cfg.devices id $id]
        if {$idx == ""} {
            mk::row append cfg.devices name $name id $id state "" flag 512 macro_on 256 macro_off 256 varflag 0 loglevel 0 model "none"
            set saveflag 1
            set size [mk::view size cfg.devices]
            incr size -1
#            debug "load:new:$idx:[mk::get cfg.devices!$size]" blue
        } elseif {[mk::get cfg.devices!$idx name] ne $name} {
            mk::set cfg.devices!$idx name $name
            set saveflag 1
        } else {
#            debug "load:no change: [mk::get cfg.devices!$idx]" blue
        }
    }
#    debug "[dict get $CasetaConfig Devices Name]" red
    foreach {name id} [dict get $CasetaConfig Devices Name] {
        foreach {butname number} [dict get $CasetaConfig Devices Buttons $id] {
            set idx [mk::select cfg.devices id $id:$number]
            if {$idx == ""} {
                mk::row append cfg.devices name "$name $butname" id $id:$number state "" flag 512 macro_on 256 macro_off 256 varflag 0 loglevel 0 model "none"
                set saveflag 1
                set size [mk::view size cfg.devices]
#                debug "$size " darkred
                incr size -1
#                debug "load:new:$size:[mk::get cfg.devices!$size]" blue
            } elseif {[mk::get cfg.devices!$idx name] ne "$name $butname"} {
                mk::set cfg.devices!$idx name "$name $butname"
#                debug "load:name change:$idx: [mk::get cfg.devices!$idx]" blue
                set saveflag 1
            } else {
#                debug "load:no change:$idx: [mk::get cfg.devices!$idx]" blue
            }
        }
    }

    debug "Config Version: $cfg(version)" green

    # set any missing cfg items into cfg.main
    foreach {var val} [array get cfg] {
        if {[mk::select cfg.main name $var] == ""} {
            mk::row append cfg.main name $var value $val
            set saveflag 1
        }
    }

    if {$saveflag} {saveconfig}
}

# Save config changes to cfg file
proc saveconfig {{top ""}} {
    global cfg cfgfile

    if {[winfo exists .caseta]} {
        set cfg(geometry) [wm geometry .caseta]
    }
    mk::view size cfg.main 0
    foreach {var val} [array get cfg] {
        mk::row append cfg.main name $var value $val
    }
    set bkup caseta-[pid].$$$
    set rc [catch {hvConfigFile create $bkup w} f]
    if {$rc == 0} {
        mk::file save cfg $f
        close $f
        hvConfigFile delete $cfgfile
        hvConfigFile rename $bkup $cfgfile
    } elseif {$top ne ""} {
        ttk::messageBox -parent $top -message $f -icon error -type ok
    } else {
        debug "Failed to save configuration: $f"
    }
    return [expr {!$rc}]
}

# Caseta configuration screen
proc cfg_caseta {} {
    global cfg CasetaConfig deviceState

    if {[winfo exists .caseta]} {
        wm withdraw .caseta
        wm deiconify .caseta
        return
    }
    ttk::toplevel .caseta
    wm withdraw .caseta
    wm title .caseta "Caseta Configuration"

    ttk::notebook .caseta.nb
    # Settings Tab
    ttk::frame .caseta.nb.f2
    ttk::label .caseta.nb.f2.l12 -text "Lutron Smart Bridge IP Address:" -anchor e
    ttk::entry .caseta.nb.f2.e12 -width 25  -textvariable cfg(HubIP)

    ttk::label .caseta.nb.f2.l13 -text "Lutron Smart Bridge Port:" -anchor e
    ttk::entry .caseta.nb.f2.e13 -width 6 -justify center -textvariable cfg(HubPort)

    ttk::label .caseta.nb.f2.l15 -text "Username:" -anchor e
    ttk::entry .caseta.nb.f2.e15 -width 25 -justify center -textvariable cfg(username)
    ttk::label .caseta.nb.f2.l16 -text "Password:" -anchor e
    ttk::entry .caseta.nb.f2.e16 -width 25 -justify center -textvariable cfg(password) -show *

    ttk::label .caseta.nb.f2.l32 -text "Caseta Config File:" -anchor e
    ttk::entry .caseta.nb.f2.e32  -textvariable cfg(CasetaConfigFile) -justify right
    ttk::button .caseta.nb.f2.b32 -width 0 -text "..." -command [list sel_file .caseta cfg(CasetaConfigFile)]

    ttk::checkbutton .caseta.nb.f2.c31 -variable cfg(logging) -text "Create log file" -command cfg_logsel
    ttk::label .caseta.nb.f2.l31 -text "Log Folder:" -anchor e
    ttk::entry .caseta.nb.f2.e31  -textvariable cfg(logpath) -state readonly
    ttk::button .caseta.nb.f2.b31 -width 0 -text "..." -command [list sel_directory .caseta cfg(logpath)]
    ttk::label .caseta.nb.f2.l33 -text "Log File Extension:" -anchor e
    ttk::entry .caseta.nb.f2.e33 -textvariable cfg(txtext)

    ttk::checkbutton .caseta.nb.f2.c32 -variable cfg(mqttEnable) -text "Enable MQTT"
    ttk::separator .caseta.nb.f2.sep

    ttk::label .caseta.nb.f2.l9 -text "Netio string:" -anchor e
    ttk::entry .caseta.nb.f2.e9 -width 10 -justify center -textvariable cfg(netioType)
    ttk::label .caseta.nb.f2.l10 -text "Serial string prefix string:" -anchor e
    ttk::entry .caseta.nb.f2.e10 -width 10 -justify center -textvariable cfg(serPre)
    ttk::label .caseta.nb.f2.l11 -text "Serial string terminator character(s):" -anchor e
    ttk::entry .caseta.nb.f2.e11 -width 5 -justify center -textvariable cfg(serPost)

    grid .caseta.nb.f2.l12 .caseta.nb.f2.e12 -sticky nws -padx 3
    grid configure .caseta.nb.f2.l12     -sticky nes -padx 3
    grid .caseta.nb.f2.l13 .caseta.nb.f2.e13 -sticky nws -padx 3
    grid configure .caseta.nb.f2.l13     -sticky nes -padx 3

    grid .caseta.nb.f2.l15 .caseta.nb.f2.e15 -sticky nws -padx 3
    grid configure .caseta.nb.f2.l15     -sticky nes -padx 3
    grid .caseta.nb.f2.l16 .caseta.nb.f2.e16 -sticky nws -padx 3
    grid configure .caseta.nb.f2.l16     -sticky nes -padx 3

    grid .caseta.nb.f2.l32 .caseta.nb.f2.e32 .caseta.nb.f2.b32 -sticky we -padx 3
    grid x .caseta.nb.f2.c31 -sticky nws  -padx 3 -pady 1
    grid .caseta.nb.f2.l31 .caseta.nb.f2.e31 .caseta.nb.f2.b31 -sticky we -padx 3
    grid .caseta.nb.f2.l33 .caseta.nb.f2.e33 -sticky we -padx 3
    grid x .caseta.nb.f2.c32 -sticky nws  -padx 3 -pady 1

    grid .caseta.nb.f2.sep -column 0 -columnspan 2 -sticky ew -padx 3 -pady 3

    grid .caseta.nb.f2.l9 .caseta.nb.f2.e9   -sticky nws -padx 3
    grid configure .caseta.nb.f2.l9      -sticky nes -padx 3
    grid .caseta.nb.f2.l10 .caseta.nb.f2.e10 -sticky nws -padx 3
    grid configure .caseta.nb.f2.l10     -sticky nes -padx 3
    grid .caseta.nb.f2.l11 .caseta.nb.f2.e11 -sticky nws -padx 3
    grid configure .caseta.nb.f2.l11     -sticky nes -padx 3

    grid rowconfigure .caseta.nb.f2 all -weight 1
    grid columnconfigure .caseta.nb.f2 all -weight 1
    grid .caseta.nb.f2 -sticky news  -padx 5 -pady 5

#    .caseta.nb add .caseta.nb.f2 -text "Settings" -underline 0

       # Devices tab
    ttk::frame .caseta.nb.f1
    ttk::frame .caseta.nb.f1.lb -style TEntry -borderwidth 2
    ttk::treeview .caseta.nb.f1.lb.l -show {tree headings} -columns {id state flag macro} \
      -displaycolumns {id flag macro state} -yscrollcommand {.caseta.nb.f1.lb.s set}
    set w [font measure TkDefaultFont 0]
    .caseta.nb.f1.lb.l column #0 -width [expr {30 * $w}] -stretch 1
    .caseta.nb.f1.lb.l heading id -text "ID"
    .caseta.nb.f1.lb.l column id -width [expr {6 * $w}] -stretch 0 -anchor center
    .caseta.nb.f1.lb.l heading state -text "State"
    .caseta.nb.f1.lb.l column state -width [expr {15 * $w}] -stretch 1  -anchor center
    .caseta.nb.f1.lb.l heading flag -text "Flag/Var"
    .caseta.nb.f1.lb.l column flag -width [expr {10 * $w}] -stretch 0  -anchor center
    .caseta.nb.f1.lb.l heading macro -text "Macro"
    .caseta.nb.f1.lb.l column macro -width [expr {10 * $w}] -stretch 0  -anchor center
    ttk::scrollbar .caseta.nb.f1.lb.s -command {.caseta.nb.f1.lb.l yview}
    pack .caseta.nb.f1.lb.s -side right -fill y
    pack .caseta.nb.f1.lb.l -fill both -expand 1
    ttk::button .caseta.nb.f1.b1 -text Edit -command cfg_device_chgdlg -state disabled \
    -image [imglist quickedit] -compound left
    grid .caseta.nb.f1.lb  -padx 2 -pady 2 -sticky snew
    grid .caseta.nb.f1.b1  -padx 4 -pady 4
    grid columnconfigure .caseta.nb.f1.b1 1 -weight 0
    bind .caseta.nb.f1.lb.l <<TreeviewSelect>> {set currentItem [lindex [.caseta.nb.f1.lb.l selection] 0];cfg_devicesel %W}
    bind .caseta.nb.f1.lb.l <Double-1> {cfg_device_dbl %W %x %y}
    grid .caseta.nb.f1.lb -column 0 -columnspan 2 -sticky news -padx 3
    grid .caseta.nb.f1.b1 -column 1 -padx {4 13} -pady {2 8}
    grid rowconfigure .caseta.nb.f1 .caseta.nb.f1.lb -weight 1
    grid columnconfigure .caseta.nb.f1 1 -weight 1
    grid .caseta.nb.f1 -sticky news  -padx 5 -pady 5

    destroy .rtclkMenu
    set m [menu .rtclkMenu]
    $m add command -label "Off" -command {cfg_rtclkdlg 0}
    $m add command -label "On" -command {cfg_rtclkdlg 100}
    $m add command -label "Set To" -command {cfg_rtclkdlg setto}
    bind .caseta.nb.f1.lb.l <Button-3> [list cfg_rtclk $m %W %x %y %X %Y]

    # Save changes to column widths. Use unmapped dummy widget to
    #  capture values before the treeview widget itself is destroyed.
    ttk::label .caseta.nb.f1.lb.l.canary
    bind .caseta.nb.f1.lb.l.canary <Destroy> bindWidths

    if {[llength [lindex $cfg(listWidths) 0]] == 5} {
        foreach col {#0 #1 #2 #3 #4} wid [lindex $cfg(listWidths) 0] {
            .caseta.nb.f1.lb.l column $col -width $wid
        }
    }

    .caseta.nb add .caseta.nb.f1 -text Devices -underline 0
    .caseta.nb add .caseta.nb.f2 -text "Settings" -underline 0

    createDevList

    grid .caseta.nb    -sticky snew    -padx 5 -pady 5 -columnspan 3

    ttk::button .caseta.b3 -text Done -width 8 -command cfg_done \
        -image [imglist ok] -compound left
    grid  .caseta.b3  -columnspan 3 -padx {4 13} -pady {2 8}
    grid columnconfigure .caseta all -weight 1
    grid rowconfigure .caseta .caseta.nb -weight 1
    grid rowconfigure .caseta .caseta.b3 -weight 0
    bind .caseta <F1> {hvHelp index}
    bind .caseta <<NotebookTabChanged>> bindTabs

    if {[lindex $cfg(listWidths) 1] ne ""} {
        .caseta.nb select [lindex $cfg(listWidths) 1]
    }

    wm protocol .caseta WM_DELETE_WINDOW {.caseta.b3 invoke}

    if {[regexp {\+-?[0-9]+\+-?[0-9]+} $cfg(geometry)]} {
        wm geometry .caseta $cfg(geometry)
    }
    wm deiconify .caseta
}

proc bindWidths {} {
    global cfg
    lset cfg(listWidths) 0 [lmap col {#0 #1 #2 #3 #4} {.caseta.nb.f1.lb.l column $col -width}]
}

proc bindTabs {} {
    global cfg
    lset cfg(listWidths) 1 [.caseta.nb index current]
}

# Get images for Configuration dialog
proc imglist {i} {
    global img

    if {![info exists img($i)]} {
        set img($i) [image create photo \
            -file [file join [hvVariable ImagePath] $i.png]]
        set img([format %sdim $i]) [image create photo -format {png -alpha 0.3} \
            -file [file join [hvVariable ImagePath] $i.png]]
    }
    set dim $img([format %sdim $i])
    return [list $img($i) disabled $dim]
}

proc cfg_devicetype {w} {
    set item [$w selection]
    if {$item eq "" || [regexp {devices:.*} $item]} {
        .caseta.usr.l6 state disabled
        .caseta.usr.cb6 state disabled
        .caseta.usr.l4 state disabled
        .caseta.usr.cb state disabled
    } else {
        .caseta.usr.l6 state !disabled
        .caseta.usr.cb6 state !disabled
        .caseta.usr.l4 state !disabled
        .caseta.usr.cb state !disabled
    }
}

proc cfg_devicesel {w} {
    set p [winfo parent [winfo parent $w]]
    set item [$w selection]
    if {$item eq "" || ![regexp {(zone:|devices:[0-9]+:)[0-9]+} $item]} {
        $p.b1 state disabled
    } else {
        $p.b1 state !disabled
    }
}

# Double-click enters edit mode
proc cfg_device_dbl {w x y} {
    # Use identify row instead of item for compatibility with 8.5.8 and 8.5.9
    set p [winfo parent [winfo parent $w]]
    set row [$w identify row $x $y]
    if {$row ne "" && [regexp {(zone:|devices:[0-9]+:)[0-9]+} $row]} {
        $p.b1 invoke
    }
}

proc cfg_logsel {} {
    global cfg

    if {$cfg(logging)} {
         grid .caseta.nb.f2.l31 .caseta.nb.f2.e31 .caseta.nb.f2.b31 -sticky we -padx 3
         grid .caseta.nb.f2.l33 .caseta.nb.f2.e33 -sticky we -padx 3
    } else {
        grid remove .caseta.nb.f2.l31 .caseta.nb.f2.e31 .caseta.nb.f2.b31
        grid remove .caseta.nb.f2.l33 .caseta.nb.f2.e33
    }
}

proc sel_directory {top name} {
    upvar #0 $name var

    set dir [ttk::chooseDirectory -initialdir $var -mustexist 1 \
      -parent $top -title "Select directory"]
    if {$dir ne ""} {set var $dir}
}

proc sel_file {top name} {
    global dir
    upvar #0 $name var

    set file [tk_getOpenFile -initialdir $dir -initialfile $var  \
      -parent $top -title "Select Caseta Config File"]
    if {$file ne ""} {set var $file}
}

# Create device list, with updated state
proc createDevList {} {
    global CasetaConfig deviceState currentItem

    if {[winfo exist .caseta.usr]} {return}
    if {[winfo exist .caseta]} {
        if {![info exists CasetaConfig] || ![dict exists $CasetaConfig Zones Name]} {return}
        set win .caseta.nb.f1.lb.l
        $win delete [$win children {}]
        set names {
            zone	"Zones"
            devices "Devices"
        }
        set n zone
        $win insert {} end -id $n -text [dict get $names $n]
        set i 0
        foreach {name id} [dict get $CasetaConfig Zones Name] {
            if {[info exist deviceState] && [dict exists $deviceState id $id]} {
                set level [dict get $deviceState id $id level]
                if {$level == 0} {
                    set level "OFF"
                } else {
                    set level "ON $level"
                }
            } else {
                set level "--"
            }

            set row [mk::select cfg.devices -exact id $id]
            if {$row ne ""} {
                lassign [mk::get cfg.devices!$row flag macro_on macro_off] flag macro_on macro_off
            } else {
                set flag 512
                set macro_on 256
                set macro_off 256
            }
            if {$flag == 512} {
                set flag "-"
            } else {
                if {$flag > 255} {
                    set flag VA-[expr {$flag - 256}]
                } else {
                    set flag FL-$flag
                }
            }
            set macro [expr {$macro_on < 256?$macro_on:"-"}]/[expr {$macro_off < 256?$macro_off:"-"}]
            $win insert $n end -id $n:$i -text $name \
            -values [list $id $level $flag $macro $n $i]
            incr i
        }
        set n devices
        $win insert {} end -id $n -text [dict get $names $n]
        set i 0
        foreach {dname id} [dict get $CasetaConfig Devices Name] {
            $win insert $n end -id $n:$i -text $dname -values [list $id]
            set j 0
            foreach {name number} [dict get $CasetaConfig Devices Buttons $id] {
                $win insert $n:$i end -id $n:$i:$j -text "$dname $name" \
                -values [list $id:$number "-" $flag $macro $n $j]
                incr j
            }
            incr i
        }
    }
    if {$currentItem ne ""} {
        $win see $currentItem
    }
}

# put up Zone/Device item right-click menu
proc cfg_rtclk {m w x y X Y} {

    set item [$w identify item $x $y]
    if {$item ne ""} {
        if {[regexp -nocase {devices:[0-9]+:[0-9]+} $item]} {
           $m entryconfigure 0 -state disabled
           $m entryconfigure 2 -state disabled
        } elseif {[regexp -nocase {zone:[0-9]+} $item]} {
           $m entryconfigure 0 -state normal
           $m entryconfigure 2 -state normal
        } else {
            return
        }
        $w selection set $item
        tk_popup .rtclkMenu $X $Y
    }
}

# process command selected in right-click menu
proc cfg_rtclkdlg {cmd} {
    global currentItem cfg

    if {$cmd eq "setto"} {
        cfg_rtclksettodlg
    } else {
        set win .caseta.nb.f1.lb.l
        set currentItem [lindex [$win selection] 0]
        if {[regexp {devices:.*} $currentItem]} {
            if {$cfg(mqttEnable)} {
                mqttComm -exactstat stat <[$win item $currentItem -text]> On
            }
        } else {
            sendCmd [$win item $currentItem -text] $cmd
        }
    }
}

proc cfg_rtclksettodlg {} {
    global setto

    ttk::toplevel .caseta.st
    wm title .caseta.st "Set Device"
    wm transient .caseta.st .caseta
    wm withdraw .caseta.st

    ttk::frame .caseta.st.f1
    ttk::label .caseta.st.f1.l1 -text "Set to Value:" -anchor w
    ttk::entry .caseta.st.f1.e1 -width 5 -textvariable setto
    ttk::frame .caseta.st.f
    ttk::button .caseta.st.f.b1 -text OK -width 6 -command [list cfg_rtclksetto] \
        -image [imglist ok] -compound left
    ttk::button .caseta.st.f.b2 -text Cancel -width 6 -command {destroy .caseta.st} \
        -image [imglist cancel] -compound left
    grid .caseta.st.f1.l1   .caseta.st.f1.e1   -padx 4  -pady 1 -sticky we
    grid configure    .caseta.st.f1.l1    -padx 3  -sticky nes
    grid .caseta.st.f1         -       -padx 4  -pady 3 -sticky we
    grid .caseta.st.f.b1 .caseta.st.f.b2 -padx 20 -pady 4
    grid .caseta.st.f         -       -padx 4  -pady 3 -sticky we
    grid anchor .caseta.st.f1 center
    grid anchor .caseta.st.f center
    bind .caseta.st.f1.e1 <Return> {.caseta.st.f.b1 invoke}
    bind .caseta.st <F1> {hvHelp index}
    center .caseta.st .caseta
    grab .caseta.st
    focus .caseta.st.f1.e1
}

proc cfg_rtclksetto {} {
    global setto currentItem

    if {[string is integer -strict $setto] || [string is double -strict $setto] } {
        set win .caseta.nb.f1.lb.l
        set currentItem [lindex [$win selection] 0]
#        lassign [$win item $currentItem -text] name
        sendCmd [$win item $currentItem -text] $setto
    }
    destroy .caseta.st
}

proc cfg_device_chgdlg {} {
    global casname casid casstate casflag casmacro_on casmacro_off casvarflag varflag

    set item [lindex [.caseta.nb.f1.lb.l selection] 0]
    set casname [.caseta.nb.f1.lb.l item $item -text]
    lassign [.caseta.nb.f1.lb.l item $item -values] casid  casstate c macro
    debug "cfg_device_chgdlg:$item,$casname,$casid,$casstate,$c,$macro;" red
    if {$c eq "-"} {
        set casflag 512
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "VA"} {
            set casflag [expr {$num + 256}]
        } else {
            set casflag $num
        }
    }
     lassign [split $macro /] casmacro_on casmacro_off
    if {$casmacro_on eq "-"} {
        set casmacro_on 256
    }
    if {$casmacro_off eq "-"} {
        set casmacro_off 256
    }
    cfg_device_adddlg
    .caseta.usr.f.b1 configure -command [list cfg_device_chg $item]
}

proc cfg_device_adddlg {} {
    global casname casvarflag varflag casvardbl vardbl casloglevel logrx logtx casetatypes casmodel

    set row [mk::select cfg.devices name $casname]
    if {$row ne ""} {
        lassign [mk::get cfg.devices!$row varflag loglevel model] varflag loglevel model
        set vardbl [expr {($varflag & 0x02)>>1}]
        set casvardbl $vardbl
        set varflag [expr {$varflag & 0x01}]
        set casvarflag $varflag
        set casloglevel $loglevel
        set logtx [expr {($loglevel & 0x02)>>1}]
        set logrx [expr {$loglevel & 0x01}]
    }

    ttk::toplevel .caseta.usr
    wm title .caseta.usr "Configure Device"
    wm transient .caseta.usr .caseta
    wm withdraw .caseta.usr
    ttk::label .caseta.usr.l1 -text "Name:" -anchor w
    ttk::entry .caseta.usr.e1 -width 20 -textvariable casname
    ttk::label .caseta.usr.l3 -text "Model:"
    ttk::combobox .caseta.usr.c3 -state readonly -width 40 \
      -values [dict values $casetatypes]
    ttk::label .caseta.usr.l4 -text "Flag/Var:" -anchor w
    ttk::combobox .caseta.usr.cb -state readonly -width 28
    bind .caseta.usr.cb <<ComboboxSelected>> [list cfg_flag_set .caseta.usr.cb]
    createflaglist .caseta.usr.cb
    ttk::frame .caseta.usr.f1
    ttk::checkbutton .caseta.usr.f1.xb1 -text "Use Variable as flag" -command {cfg_varflag ext} -variable varflag
    ttk::checkbutton .caseta.usr.f1.xb2 -text "Use two Variables" -command {cfg_varflag dbl} -variable vardbl
    ttk::label .caseta.usr.f1.xl2 -textvariable varlist -anchor w
    ttk::label .caseta.usr.l5 -text "On Macro:" -anchor w
    ttk::combobox .caseta.usr.cb5 -state readonly -width 28
    bind .caseta.usr.cb5 <<ComboboxSelected>> [list cfg_macro_set .caseta.usr.cb5 casmacro_on]
    createmacrolist .caseta.usr.cb5 casmacro_on
    ttk::label .caseta.usr.l6 -text "Off Macro:" -anchor w
    ttk::combobox .caseta.usr.cb6 -state readonly -width 28
    bind .caseta.usr.cb6 <<ComboboxSelected>> [list cfg_macro_set .caseta.usr.cb6 casmacro_off]
    createmacrolist .caseta.usr.cb6 casmacro_off
    ttk::frame .caseta.usr.f2
    ttk::checkbutton .caseta.usr.f2.xb3 -text "Log received messages" -variable logrx
    ttk::checkbutton .caseta.usr.f2.xb4 -text "Log sent messages" -variable logtx
    ttk::separator .caseta.usr.sep
    ttk::frame .caseta.usr.f
    ttk::button .caseta.usr.f.b1 -text OK -width 6 -command cfg_device_chg  \
        -image [imglist ok] -compound left
    ttk::button .caseta.usr.f.b2 -text Cancel -width 6 -command {destroy .caseta.usr;#cfg_sortlist ext} \
        -image [imglist cancel] -compound left

    if {![catch {mk::get cfg.devices!$row model} casmodel] && $casmodel ne ""} {
        .caseta.usr.c3 set [dict get $casetatypes [mk::get cfg.devices!$row model]]
    } else {
	    .caseta.usr.c3 current 0
    }

    grid .caseta.usr.f.b1 .caseta.usr.f.b2 -padx 20 -pady 4
    grid anchor .caseta.usr.f center
    grid .caseta.usr.f1.xb1 -padx 4 -pady 1 -sticky w
#   grid .caseta.usr.f1.xb2 .caseta.usr.f1.xl2 -padx 4 -pady 1 -sticky w
    grid .caseta.usr.l1   .caseta.usr.e1  -padx 4 -pady 1 -sticky we
    grid .caseta.usr.l3 .caseta.usr.c3 -padx 4 -pady 1 -sticky we
    grid .caseta.usr.l4   .caseta.usr.cb  -padx 4 -pady 1 -sticky we
    grid       x        .caseta.usr.f1  -sticky w
    grid .caseta.usr.l5   .caseta.usr.cb5 -padx 4 -pady 1 -sticky we
    grid .caseta.usr.l6   .caseta.usr.cb6 -padx 4 -pady 1 -sticky we
    grid .caseta.usr.f2.xb3 -padx 4 -pady 1
    grid .caseta.usr.f2.xb4 -padx 4 -pady 1 -sticky we
    grid       x      .caseta.usr.f2 -sticky w
    grid .caseta.usr.sep - -padx 2 -pady {2 0} -sticky we
    grid .caseta.usr.f - -padx 4 -pady 3 -sticky we
    grid columnconfigure .caseta.usr .caseta.usr.e1 -weight 1
#    bind .caseta.usr.e1 <Return> {.caseta.usr.f.b1 invoke}
    bind .caseta.usr <F1> {hvHelp users}
    center .caseta.usr .caseta
    grab .caseta.usr
    .caseta.usr.e1 state disabled

    cfg_varflag_select
    cfg_varflag ext
    cfg_devicetype .caseta.nb.f1.lb.l
}

proc cfg_device_chg {item} {
    global casname casid casstate casflag casmacro_on casmacro_off casvarflag varflag casvardbl vardbl casloglevel logrx logtx casmodel casetatypes

    set name [.caseta.nb.f1.lb.l item $item -text]
    lassign [.caseta.nb.f1.lb.l item $item -values] id state c macro
    if {$c eq "-"} {
        set flag 512
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "VA"} {
            set flag [expr {$num + 256}]
        } else {
            set flag $num
        }
    }
    lassign [split $macro /] macro_on macro_off
    if {$macro_on eq "-"} {
        set macro_on 256
    }
     if {$macro_off eq "-"} {
        set macro_off 256
    }
    set casmodel [lindex [dict keys $casetatypes] [.caseta.usr.c3 current]]

    set row [mk::select cfg.devices -exact name $name]
    if {![catch {mk::get cfg.devices!$row model}]} {
        set model [mk::get cfg.devices!$row model]
    } else {
        set model ""
    }

    if {$casname eq $name \
         && $casmodel eq $model \
         && $casstate eq $state && $casflag eq $flag \
         && $casmacro_on eq $macro_on && $casmacro_off eq $macro_off \
         && $casvarflag eq $varflag && $casvardbl eq $vardbl \
         && $casloglevel eq ($logrx | $logtx<<1)} {
        debug "Nothing changed"
        destroy .caseta.usr
#        cfg_sortlist ext
        return
    }

    if {$casflag == 512} {
        set flag "-"
    } else {
        if {$casflag > 255} {
            set flag VA-[expr {$casflag - 256}]
        } else {
            set flag FL-$casflag
        }
    }
    set macro [expr {$casmacro_on < 256?$casmacro_on:"-"}]/[expr {$casmacro_off < 256?$casmacro_off:"-"}]

    mk::set cfg.devices!$row name $casname id $casid model $casmodel flag $casflag  macro_on $casmacro_on macro_off $casmacro_off varflag [expr {$varflag | ($vardbl<<1)}] loglevel [expr {$logrx | ($logtx<<1)}]

    .caseta.nb.f1.lb.l item $item -values [list $casid $casstate $flag $macro ]
    destroy .caseta.usr
#    cfg_sortlist ext
}

proc cfg_flag_set {w} {
    global casflag

    set c [lindex [split [$w get] ":"] 0]
    if {$c eq "None" || $c eq "-"} {
        set casflag 512
    } else {
        lassign [split $c {-}] grp num
        if {$grp eq "VA"} {
            set casflag [expr {$num + 256}]
        } else {
            set casflag $num
        }
    }
    cfg_varflag_select
    createflaglist $w
}

#! Create flag list for drop-down box
proc createflaglist {widget} {
    global casflag connected

    set fcnt 0
    set vcnt 0
    if {$connected} {
        set fcnt [hvObjectCount flag]
        set vcnt [hvObjectCount var]
    }

    set val "None"
    for {set v 0; set i 1} {$v < $fcnt} {incr v} {
        set name [hvObjectName flag $v]
        lappend val "FL-$v:$name"
        incr i
    }
    for {set v 0; set i 1} {$v < $vcnt} {incr v} {
        set name [hvObjectName var $v]
        lappend val "VA-$v:$name"
        incr i
    }

     $widget configure -values $val
    if {[llength $val] > 1 && $casflag ne "" && $casflag < 512} {
        if {$casflag < 256} {
            $widget current [expr {$casflag + 1}]
        } else {
            $widget current [expr {$casflag + $fcnt - 255}]
        }
    } else {
        $widget current 0
        set casflag 512
    }
}

proc cfg_varflag {type} {
    global varflag vardbl

    if {$type in {ext}} {
        if {$varflag == 1} {
            .caseta.usr.f1.xb2 state disabled
            .caseta.usr.f1.xl2 state disabled
            set vardbl 0
        } else {
            .caseta.usr.f1.xb2 state !disabled
            .caseta.usr.f1.xl2 state !disabled
        }
    }
}

proc cfg_varflag_select {} {
    global casflag varlist vardbl

    if {$casflag > 255 && $casflag < 512} {
       set casid [expr {$casflag - 256}]
       grid x .caseta.usr.f1
       if {$casid+1 == [hvObjectCount var]} {
           set varlist "(VA-[expr {$casid+1}] Not available.)"
           set vardbl 0
       } else {
            set varlist "(VA-$casid, VA-[expr {$casid+1}])"
       }
    } else {
       grid remove .caseta.usr.f1
    }
}

#! Process a macro when selected for a device
proc cfg_macro_set {w var} {
    upvar #0 $var macro

    set c [lindex [split [$w get] ":"] 0]
    if {$c eq "None" || $c eq "-"} {
        set macro 256
    } else {
        set macro $c
    }
    createmacrolist $w $var
}
#! Create macro list for drop-down box
proc createmacrolist {widget var} {
    global connected
    upvar #0 $var macro

    set cnt 0
    if {$connected} {
        set cnt [hvObjectCount macro]
    }
    set val "None"
    for {set v 0; set i 1} {$v < $cnt} {incr v} {
        set name [hvObjectName macro $v]
        lappend val "$v:$name"
        incr i
    }

    $widget configure -values $val
    if {[llength $val] > 1 && $macro ne "" && $macro < 256} {
        $widget current [expr {$macro + 1}]
    } else {
        $widget current 0
        set macro 256
    }
}

proc cfg_done {} {
    global cfg currentItem

    mk::loop row cfg.main {
        array set tmpcfg [mk::get $row name value]
    }
#    debug [array get cfg] red
#    debug [array get tmpcfg] blue
    if {$tmpcfg(HubIP) ne $cfg(HubIP) || $tmpcfg(HubPort) ne $cfg(HubPort) \
        || $tmpcfg(username) ne $cfg(username) \
        || $tmpcfg(password) ne $cfg(password) }  {
        startClient $cfg(attempts)
    }
    if {$tmpcfg(CasetaConfigFile) ne $cfg(CasetaConfigFile)} {
        getCasetaConfig
    }
    if {$tmpcfg(serPre) ne $cfg(serPre)} {
        hvTrigger $tmpcfg(serPre) {}
        hvTrigger $cfg(serPre) [list casetaSerial]
    }
    saveconfig
    startClient $cfg(attempts)
    subscribe

    set currentItem ""
    destroy .caseta
}

package require json 1.0
proc getCasetaConfig {} {
    global cfg CasetaConfig dir

    debug $cfg(CasetaConfigFile) blue
    unset -nocomplain CasetaConfig

    if {[catch {open $cfg(CasetaConfigFile) r} cf]} {
        debug "Failed to open Caseta Config file" red
        tk_messageBox -icon error -message "Failed to open Config File" -detail "$cfg(CasetaConfigFile)\nCheck file path."
        return
    }
    if {[catch {chan read $cf} data]} {
        debug "Failed to read Caseta Config file" red
        tk_messageBox -icon error -message "Failed to open Config File" -detail "$cfg(CasetaConfigFile)\nCheck file."
        return
    }
    if {[catch {::json::json2dict $data} ctmp]} {
        debug "Failed to parse json:$ctmp" red
        tk_messageBox -icon error -message "Error Parsing Config File" -detail "$cfg(CasetaConfigFile)\nCompare to Lutron email."
        return
    }
#    debug $ctmp
#    debug [dict get $ctmp LIPIdList Zones]
    foreach dev [dict get $ctmp LIPIdList Zones] {
        set id [dict get $dev ID]
        set name [dict get $dev Name]
        dict set CasetaConfig Zones Name $name $id
        dict set CasetaConfig Zones ID $id $name
        debug "$id,$name" red
    }
    foreach dev [dict get $ctmp LIPIdList Devices] {
        set id [dict get $dev ID]
        if {$id == 1} continue
        set name [dict get $dev Name]
        dict set CasetaConfig Devices Name $name $id
        dict set CasetaConfig Devices ID $id $name
        set buttons {}
        foreach button [dict get $dev Buttons] {
            set number [dict get $button Number]
            if {[dict exists $$button Name]} {
                set butname [dict exists $$button Name]
            } else {
                set butname "Button $number"
            }
            debug "$id:$name:$number,$butname;" red
            lappend buttons $butname $number
        }
        dict set CasetaConfig Devices Buttons $id $buttons
        debug "$id,$name" red
    }
#    debug [dict get $CasetaConfig] blue
}

# End Config Section

# Start Trigger section

# netioaction is called by NetIO "netioaction" command.
#
# Example: sends: netioaction caseta name [off|on|on 0-100|0-100]
# "caseta" must match config's netioType.
# "name" must match an allowed device name.
#hvImport netioaction
hvPublic -origin netioaction
proc netioaction {args} {
    global cfg

    debug "netioaction:$args" red
    set args [lassign $args origin]
    if {!$cfg(mqttEnable) && [string match -nocase {mqtt*} $origin]} {return ""}
    set state [lassign $args type]
    if {$type ne $cfg(netioType)} {return ""}
    if {$state eq ""} {return ""}
    sendCmd [join $state]
}

# netio is called by NetIO "get" command.
#
# Example: reads: get caseta {status_type} name
# "caseta" must match config's netioType.
# "name" must match an allowed device name.
# "status_type", if present, must be:
#    state, status, image, slider, name, namestate, or namestatus.
# If "status_type" is not present, "status" is assumed.
hvPublic -origin netio
proc netio {args} {
    global cfg deviceState CasetaConfig

    debug "netio: $args" red
    set args [lassign $args origin]
    if {!$cfg(mqttEnable) && [string match -nocase {mqtt*} $origin]} {return ""}
    set name [lassign $args type state]
    set state [string tolower $state]
    if {$state ni {state status image slider name namestate namestatus}} {
        lassign $args type name
        set state status
    }
    if {$type ne $cfg(netioType)} {return ""}
    regexp {^<*([^<>]+)>*$} $name --> name
    set name [string map {\{ "" \} ""} $name]
    debug "name:$name,state:$state;" red
    if {![info exists CasetaConfig] || ![dict exists $CasetaConfig Zones Name $name]} {return}
    set id [dict get $CasetaConfig Zones Name $name]
    if {[info exist deviceState] && [dict exists $deviceState id $id]} {
        set level [expr {int([dict get $deviceState id $id level])}]
        if {$level == 0} {
            set rc "Off"
        } else {
            set rc "On"
        }
        debug "netio:rc:$rc;state:$state;" red
        switch $state {
            state {
            }
            status {
                if {$level != 0} {
                    set rc "$rc $level"
                }
            }
            image {
                if {$level == 0} {
                    rc "gray"
                } else {
                    rc "green"
                }
            }
            slider {
                set rc $level
            }
            name {
                set rc $name
            }
            namestate {
                set rc "$name: $rc"
            }
            namestatus {
                if {$level != 0} {
                    set rc "$rc $level"
                }
                set rc "$name: $rc"
            }
            default {
                set rc ""
            }
        }
        return $rc
    } else {
        return ""
    }
}

# Serial string to trigger switch
#
# Example: caseta: name [off|on|on 0-100|0-100];
# "caseta:" should be config's serPre (serial Prefix string).
# "name" must match an allowed device name.
# ";" should be config's serPost (serial terminator character(s)),
#     which should not be any character(s) present in name.
# A single space must follow serPre and precede the key string.
proc casetaSerial {data} {
    global cfg sockChan

    debug "serial: $data" red
    set fmt [format {%1$s ([^%2$s]+)%2$s} $cfg(serPre) $cfg(serPost)]
    if {![regexp -nocase $fmt $data match state]} {
        debug "fail"
        return 0
    } elseif {$state eq ""} {
        return -1
    } else {
        sendCmd $state
        return [string length $match]
    }
}

hvPublic mqttReady
proc mqttReady {state} {
    if {[lindex $state 0] == "connected"} {
        cinit
    } else {
        #code to run when MQTT is not ready.
    }
}

# End Trigger section

# Init section

if {[hvGuiInit]} {
    # Set combobox foreground to gray when disabled
    ttk::style map TCombobox -foreground \
        [list disabled #8c8c8c]

    # create menus
    hvMenu [hvMainMenu Main.plugins Plugins] add command \
        -label "Caseta" -command cfg_caseta

    if {[hvHelpFile caseta.hlp]} {
        hvMenu [hvMainMenu Help.plugins Plugins] add command \
            -label "Caseta" -command [list hvHelp index]
    }
    # Translate Enter to Return
    bind all <Key-KP_Enter> {event generate %W <Key-Return>}
}

proc init {} {
    global cfg

    debug "Init!" blue

    loadConfig
    cinit
    hvTrigger $cfg(serPre) [list casetaSerial]
}

#may not need this!!!!
proc cinit {{retry 10}} {
    global connected cfg

    debug "cinit!" blue

    after cancel cinit
    if {!$connected && $retry > 0} {
        after 2000 [list cinit [expr {$retry - 1}]]
        casetaLog "Not Connected to Controller, waiting, $retry" red
        return
    }
    if {!$connected} {
        casetaLog "Not Connected to Controller, try Client anyway." red
    } else {
        casetaLog "Connected to Controller!" red
    }
    startClient $cfg(attempts)
    subscribe
}

proc disconnect {} {
    global sockChan

    casetaLog "BYE!" red
    subscribe unsub
    catch {chan close $sockChan}
}

proc discinit {} {
    global connected

    casetaLog "Disconnected from Controller!" red
    set connected 0
    subscribe unsub
    #wait for reconnect
    cinit
}

# End Init section
# Track connection to HV controller
hvEventHook connect [list set connected 1]
hvEventHook disconnect discinit
# Start when HomeVisionXL is ready
# Reconfigure when a new schedule is opened
hvEventHook ready init
# Gracefully close session when exiting
hvEventHook exit disconnect

debug $version red
